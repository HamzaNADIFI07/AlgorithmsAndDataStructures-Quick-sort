{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TP tri rapide","text":""},{"location":"#etat-du-tp","title":"\u00c9tat du TP","text":"<p>D\u00e9crivez ici l'\u00e9tat d'avancement du TP.</p>"},{"location":"#reponses-aux-questions","title":"R\u00e9ponses aux questions","text":"<p>Indiquez ici les r\u00e9ponses aux questions pos\u00e9es dans le TP. Vous reprendrez le num\u00e9ro de la section et le num\u00e9ro de la question. Par exemple pour r\u00e9pondre \u00e0 la question 3 de la section 2.4 vous indiquerez :</p>"},{"location":"#a-propos-des-tableaux-numpy","title":"\u00c0 propos des tableaux NumPy","text":"<p>Apr\u00e8s avoir lancer l'interpr\u00e9teur Python avec la commande <code>python3</code>, j'ai pu me familiariser avec les tableaux NumPy, avec les instructions suivantes:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; tab = np.array([i for i in range(10)])\n&gt;&gt;&gt; tab\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; tab[0]\n0\n&gt;&gt;&gt; tab[-1]\n9\n&gt;&gt;&gt; len(tab)\n10\n&gt;&gt;&gt; for i in tab:\n...     print(i)\n... \n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>"},{"location":"#rappels-sur-le-tri-rapide","title":"Rappels sur le tri rapide","text":""},{"location":"#q1","title":"Q1:","text":"<p>Parmi les algorithmes de tris qui opte une approche de tri sur place, on a:</p> <ul> <li>Tri \u00e0 bulles.</li> <li>Tri par insertion.</li> <li>Tri par s\u00e9lection.</li> <li>Tri par tas.</li> </ul>"},{"location":"#q2","title":"Q2:","text":"<p>Pour partitionner un tableau sans avoir \u00e0 utiliser de l'espace m\u00e9moire suppl\u00e9mentaire, il faut faire des \u00e9changes d'\u00e9l\u00e9ments.</p>"},{"location":"#q3","title":"Q3:","text":"<p>Afin de d\u00e9terminer que le partitionnement est correctement r\u00e9alis\u00e9, il faut que:</p> <ul> <li> <p>La longueur des deux partitions soit \u00e9gale \u00e0 celle du tableau initial pass\u00e9 en param\u00e8tre.</p> </li> <li> <p>Le premier \u00e9l\u00e9ment <code>(le pivot)</code> du deuxi\u00e8me tableau partitionn\u00e9 soit strictement sup\u00e9rieur \u00e0 tous ceux du premi\u00e8re tableau, mais aussi inf\u00e9rieur ou \u00e9gal aux \u00e9l\u00e9ments du second tableau.</p> </li> </ul>"},{"location":"#q4","title":"Q4:","text":"<p>Apr\u00e8s avoir tester nos exemples impl\u00e9ment\u00e9s dans la doctest de la fonction <code>partition</code>, avec la commande </p> <pre><code>python3 sorting.py\n</code></pre> <p>On constate que tous les tests ont r\u00e9ussi avec succ\u00e8s.</p>"},{"location":"#q9","title":"Q9:","text":"<p>Le tri rapide est un algorithme r\u00e9cursif, donc la m\u00e9moire suppl\u00e9mentaire utilis\u00e9e est due \u00e0 la pile des appels r\u00e9cursifs, ainsi que le nombre de ces appels r\u00e9cursifs est influenc\u00e9 par le choix du pivot.</p>"},{"location":"#la-complexite-asymptotique-en-espace-dans-le-meilleur-des-cas-log-n","title":"La complexit\u00e9 asymptotique en espace dans le meilleur des cas (log n):","text":"<p>Dans le meilleur des cas, le pivot est au milieu du tableau, donc \u00e0 chaque \u00e9tape, le tableau est divis\u00e9 en deux moiti\u00e9s,</p> <p>Ce qui nous donne une complexit\u00e9 asymptotique en espace de:</p> <pre><code>O(log n)\n</code></pre>"},{"location":"#la-complexite-asymptotique-en-espace-dans-le-pire-des-cas-n","title":"La complexit\u00e9 asymptotique en espace dans le pire des cas (n):","text":"<p>Dans le pire des cas, le pivot est toujours le plus petit ou le plus grand \u00e9l\u00e9ment, car dans ce cas \u00e0 chaque \u00e9tape de r\u00e9sursion, on ne tri qu'un seul \u00e9lement du tableau, donc chaque appel ne r\u00e9duit la taille du tableau que d\u2019un seul \u00e9l\u00e9ment.</p> <p>Ce qui nous donne une complexit\u00e9 asymptotique en espace de:</p> <pre><code>n\n</code></pre>"},{"location":"#selection-du-pivot","title":"S\u00e9lection du pivot","text":""},{"location":"#pivot-aleatoire","title":"Pivot al\u00e9atoire","text":""},{"location":"#q3_1","title":"Q3:","text":"<p>Apr\u00e8s avoir modifier la fonction main de <code>test.py</code>, pour afficher le nombre de comparaisons effectu\u00e9es par le tri fusion et le tri rapide, j'ai eu comme r\u00e9sultat:</p> <pre><code>[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27\n 28 29]\nYes !!\nNombre de comparaison du tri fusion:  114\nYes !!\nNombre de comparaison du tri rapide:  123\n</code></pre>"},{"location":"#q4_1","title":"Q4:","text":"<p>L'analyse des comparaisons effectu\u00e9es par MergeSort, QuickSort avec pivot na\u00eff et QuickSort avec pivot al\u00e9atoire pour des tailles de tableau de 1 \u00e0 100 montre les tendances suivantes :</p> <p>1\ufe0f- MergeSort:</p> <ul> <li>Suit une complexit\u00e9 O(n log n), avec une croissance progressive et stable du nombre de comparaisons, ce qui le rend pr\u00e9visible et efficace, m\u00eame dans le pire des cas.</li> </ul> <p>2\ufe0f- QuickSort avec pivot na\u00eff:</p> <ul> <li>Effectue beaucoup plus de comparaisons que les autres versions, en raison de cas d\u00e9favorables fr\u00e9quents.</li> </ul> <p>3\ufe0f- QuickSort avec pivot al\u00e9atoire:</p> <ul> <li>R\u00e9duit efficacement le pire cas en \u00e9quilibrant mieux les partitions.</li> <li>Son nombre de comparaisons est plus proche de O(n log n), le rendant beaucoup plus efficace que le pivot na\u00eff.</li> </ul>"},{"location":"#q5","title":"Q5:","text":"<p>L'int\u00e9r\u00eat du tri rapide par rapport au tri fusion est que il est g\u00e9n\u00e9ralement plus rapide, surtout avec un pivot bien choisi, ainsi qu'il est plus efficace en termes de m\u00e9moire que le tri fusion.</p>"},{"location":"#q7","title":"Q7:","text":"<p>Le pire cas se produit lorsque le pivot est toujours l'\u00e9l\u00e9ment le plus grand ou le plus petit du tableau.</p> <p>Si on choisit toujours le premier \u00e9l\u00e9ment comme pivot <code>(pivot na\u00eff)</code> et que le tableau est d\u00e9j\u00e0 tri\u00e9, le tri rapide va toujours partitionner de mani\u00e8re d\u00e9s\u00e9quilibr\u00e9e :</p> <ul> <li>Un sous-tableau contient n-1 \u00e9l\u00e9ments.</li> <li>L'autre sous-tableau est vide.</li> </ul> <p>Exemple: Si on prend un tableau <code>[1, 2, 3, 4, 5]</code>, et que le premier \u00e9l\u00e9ment est toujours choisi comme pivot, la partition va produire :</p> <pre><code>Pivot = 1 \u2192 [] | [2, 3, 4, 5]\nPivot = 2 \u2192 [] | [3, 4, 5]\nPivot = 3 \u2192 [] | [4, 5]\n...\n\n</code></pre> <p>Equation de recurrence:</p> <pre><code>T ( n ) = T ( n \u2212 1 ) + n\n</code></pre> <p>Complexit\u00e9 du Pire Cas:</p> <p>La complexit\u00e9 dans le pire des cas en temps est repr\u00e9sent\u00e9 comme suit:</p> <ul> <li> <p>Chaque partition prend O(n) comparaisons.</p> </li> <li> <p>Chaque appel r\u00e9cursif traite presque toute la liste, ce qui nous donne une profondeur de r\u00e9cursion O(n).</p> </li> </ul> <p>Donc, O(n) * O(n) = O(n\u00b2)</p> <p>Donc la complexit\u00e9 dans le pire des cas en temps est :</p> <pre><code>O ( n\u00b2 )\n</code></pre>"},{"location":"#pivot-optimal","title":"Pivot optimal","text":""},{"location":"#q1_1","title":"Q1:","text":"<p>Th\u00e9oriquement la meilleure valeur \u00e0 choisir pour le pivot est la m\u00e9diane du tableau parce qu'il garantit que chaque partition divise le tableau en deux moiti\u00e9s \u00e9gales, ce qui r\u00e9duit la profondeur de r\u00e9cursion \u00e0 O(log n), ce qui donne une complexit\u00e9 de O(n log n) dans tous les cas.</p>"},{"location":"#q4_2","title":"Q4:","text":"<p>Courbe qui rer\u00e9sente le nombre moyen de comparaisons du tri fusion, tri rapide avec na\u00efve pivot et tri rapide avec pivot al\u00e9atoire d'un tableau de contenu al\u00e9atoire:</p> <p></p> <p>Courbe qui rer\u00e9sente le nombre moyen de comparaisons du tri fusion, tri rapide avec na\u00efve pivot et tri rapide avec pivot al\u00e9atoire d'un tableau de contenu croissant:</p> <p></p> <p>Courbe qui rer\u00e9sente le nombre moyen de comparaisons du tri rapide avec pivot optimal d'un tableau de contenu al\u00e9atoire:</p> <p></p> <p>Courbe qui rer\u00e9sente le nombre moyen de comparaisons du tri fusion, tri rapide avec na\u00efve pivot et tri rapide avec pivot al\u00e9atoire d'un tableau de contenu al\u00e9atoire, tableau de contenu croissant, tri rapide avec pivot optimal d'un tableau de contenu al\u00e9atoire:</p> <p></p> <p>Apr\u00e8s analyse des courbes, on peut constater que le tri fusion est le plus efficaces en terme de nombre de comparaisons peut importe le contenu du tableau \u00e0 tri\u00e9 <code>(al\u00e9atoire, croissant)</code>, en deuxi\u00e8me position on trouve le tri rapide avec pivot optimal, et c'est \u00e0 cause du fais que le pivot est toujours au milieu du tableau ce qui cause une d\u00e9coupe du tableau sur deux tableau ce qui nous donne une pile de recursion de <code>(log n)</code>, en troixi\u00e8me position on trouve le tri rapide avec pivot al\u00e9atoire, et en derni\u00e8re position on trouve le tri rapide avec na\u00efve pivot surtout quand le contenu du tableau est croissant ou bien d\u00e9croissant parce comme le pivot est toujours en premi\u00e8re position, si le tableau est croisant le pivot sera toujours petit par rapport \u00e0 tout les autres \u00e9lements du tableau et s'il est d\u00e9croissant le pivot sera toujours plus grand par rapport \u00e0 tout les autres \u00e9lements du tableau ce qui causera le fait dans chaque appels r\u00e9cursifs, on va tri\u00e9 qu'un seul \u00e9lement ce qui nous fera une compl\u00e9xit\u00e9 de <code>O ( n\u00b2 )</code></p>"},{"location":"#q5_1","title":"Q5:","text":"<p>\u00c9quation de r\u00e9currence du tri rapide avec pivot optimal:</p> <pre><code>T ( n ) = 2 T ( n / 2 ) + n\n</code></pre> <p>La complexit\u00e9 en temps dans le meilleur des cas:</p> <p>La complexit\u00e9 en temps dans le meilleur des cas est:</p> <pre><code>O ( n log n )\n</code></pre>"},{"location":"#pivot-reellement-optimal","title":"Pivot r\u00e9ellement optimal ?","text":""},{"location":"#q1_2","title":"Q1:","text":"<p>Le tri rapide avec choix du pivot optimal n'est pas toujours meilleur, parce qui'il n\u00e9cessite une certain un calcul suppl\u00e9mentaire pour d\u00e9terminer le pivot, donc parfois un peut dire que le tri rapide avec pivot al\u00e9atoire est plus efficace parce qu'il ne n\u00e9cessite aucun calcul suppl\u00e9mentaire pour d\u00e9terminer le pivot.</p>"},{"location":"modules/","title":"Modules pour le TP sur le tri rapide","text":""},{"location":"modules/#module-element","title":"Module <code>Element</code>","text":""},{"location":"modules/#src.element.Element","title":"<code>Element</code>","text":"<p>An Element has a value and can be compared to another Element.</p> Source code in <code>src/element.py</code> <pre><code>@total_ordering\nclass Element:\n    '''\n    An Element has a value and can be compared to another Element.\n    '''\n\n    def __init__(self,value):\n        assert(type(value) == int)\n        self.value = value\n\n    def __add__ (self, other):\n        return Element(self.value + other.value)\n\n    def __eq__(self, other):\n        return self.value == other.value\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __lt__(self, other):\n        return self.value &lt; other.value\n\n    def __repr__(self):\n        return \"{}\".format(self.value)\n\n    def cmp (self,other):\n        \"\"\"\n        Compares this element and `other`.\n\n        Args:\n          other (Element): The other Element\n\n        Returns:\n          int: -1, 0 or 1 resp. if `self &lt; other`, `self` = `other` or `self` &gt; `other`\n\n        Examples:\n          &gt;&gt;&gt; Element(45).cmp(Element(234))\n          -1\n          &gt;&gt;&gt; Element(45).cmp(Element(45))\n          0\n          &gt;&gt;&gt; Element(45).cmp(Element(24))\n          1\n        \"\"\"\n        if self.value == other.value:\n            return 0\n        elif self.value &lt; other.value:\n            return -1\n        else:\n            return 1\n</code></pre>"},{"location":"modules/#src.element.Element.cmp","title":"<code>cmp(other)</code>","text":"<p>Compares this element and <code>other</code>.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Element</code> <p>The other Element</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>-1, 0 or 1 resp. if <code>self &lt; other</code>, <code>self</code> = <code>other</code> or <code>self</code> &gt; <code>other</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Element(45).cmp(Element(234))\n-1\n&gt;&gt;&gt; Element(45).cmp(Element(45))\n0\n&gt;&gt;&gt; Element(45).cmp(Element(24))\n1\n</code></pre> Source code in <code>src/element.py</code> <pre><code>def cmp (self,other):\n    \"\"\"\n    Compares this element and `other`.\n\n    Args:\n      other (Element): The other Element\n\n    Returns:\n      int: -1, 0 or 1 resp. if `self &lt; other`, `self` = `other` or `self` &gt; `other`\n\n    Examples:\n      &gt;&gt;&gt; Element(45).cmp(Element(234))\n      -1\n      &gt;&gt;&gt; Element(45).cmp(Element(45))\n      0\n      &gt;&gt;&gt; Element(45).cmp(Element(24))\n      1\n    \"\"\"\n    if self.value == other.value:\n        return 0\n    elif self.value &lt; other.value:\n        return -1\n    else:\n        return 1\n</code></pre>"},{"location":"modules/#module-generate","title":"Module <code>Generate</code>","text":"<p>Module that provides useful functions for the quicksort</p> Author <p>Dpt Informatique - FST - Univ. Lille 2016, january</p>"},{"location":"modules/#src.generate.decreasing_array","title":"<code>decreasing_array(n)</code>","text":"<p>Creates a fresh array of Elements in decreasing order.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The length of the array</p> required <p>Returns:</p> Type Description <p>NumPy array: An array of Element from n-1 to 0</p> Example <p>print(decreasing_array(3)) [2 1 0]</p> Source code in <code>src/generate.py</code> <pre><code>def decreasing_array(n):\n    \"\"\"\n    Creates a fresh array of Elements in decreasing order.\n\n    Args:\n      n (int): The length of the array\n\n    Returns:\n      NumPy array: An array of Element from n-1 to 0\n\n    Example:\n      &gt;&gt;&gt; print(decreasing_array(3))\n      [2 1 0]\n    \"\"\"\n    return np.array([Element(i) for i in reversed(range(n))])\n</code></pre>"},{"location":"modules/#src.generate.increasing_array","title":"<code>increasing_array(n)</code>","text":"<p>Creates a fresh array of Elements in increasing order.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The length of the array</p> required <p>Returns:</p> Type Description <p>NumPy array: An array of Element from 0 to n-1</p> Example <p>print(increasing_array(3)) [0 1 2]</p> Source code in <code>src/generate.py</code> <pre><code>def increasing_array(n):\n    \"\"\"\n    Creates a fresh array of Elements in increasing order.\n\n    Args:\n      n (int): The length of the array\n\n    Returns:\n      NumPy array: An array of Element from 0 to n-1\n\n    Example:\n      &gt;&gt;&gt; print(increasing_array(3))\n      [0 1 2]\n    \"\"\"\n    return np.array([Element(i) for i in range(n)])\n</code></pre>"},{"location":"modules/#src.generate.is_sorted","title":"<code>is_sorted(t)</code>","text":"<p>Predicate to test whether an array is sorted in increasing order.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>NumPy array of Element</code> <p>An array of Element</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p><code>True</code> if the array is sorted, else <code>False</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy    \n&gt;&gt;&gt; is_sorted(numpy.array([1,2,3]))\nTrue\n&gt;&gt;&gt; is_sorted(numpy.array([1,3,2]))\nFalse\n</code></pre> Source code in <code>src/generate.py</code> <pre><code>def is_sorted(t):\n    \"\"\"\n    Predicate to test whether an array is sorted in increasing order.\n\n    Args:\n      t (NumPy array of Element): An array of Element\n\n    Returns:\n      bool: `True` if the array is sorted, else `False`\n\n    Examples:\n      &gt;&gt;&gt; import numpy    \n      &gt;&gt;&gt; is_sorted(numpy.array([1,2,3]))\n      True\n      &gt;&gt;&gt; is_sorted(numpy.array([1,3,2]))\n      False\n    \"\"\"\n    n = len(t)\n    i = 0\n    while i &lt; n-1 and t[i] &lt;= t[i+1]:\n        i = i + 1\n    return i == n - 1\n</code></pre>"},{"location":"modules/#src.generate.random_array","title":"<code>random_array(n)</code>","text":"<p>Creates a fresh array of Elements in pseudo-random order. Each Element from 0 to n-1 is present only once.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The length of the array</p> required <p>Returns:</p> Type Description <p>NumPy array: An array containing Elements between 0 and n-1</p> Example <p>sorted(random_array(3)) [0, 1, 2]</p> Source code in <code>src/generate.py</code> <pre><code>def random_array(n):\n    \"\"\"\n    Creates a fresh array of Elements in pseudo-random order. Each Element from\n    0 to n-1 is present only once.\n\n    Args:\n      n (int): The length of the array\n\n    Returns:\n      NumPy array: An array containing Elements between 0 and n-1\n\n    Example:\n      &gt;&gt;&gt; sorted(random_array(3))\n      [0, 1, 2]\n\n    \"\"\"\n    l = [Element(i) for i in range(n)]\n    random.shuffle(l)\n    return np.array(l)\n</code></pre>"},{"location":"modules/#module-sorting","title":"Module <code>Sorting</code>","text":"<p>Sorting functions module for quicksort assignment</p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"modules/#src.sorting.merge","title":"<code>merge(t1, t2, cmp)</code>","text":"<p>Given two sorted arrays, creates a fresh sorted array.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>Array</code> <p>An array of objects</p> required <code>t2</code> <code>Array</code> <p>An array of objects</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required Complexity <p>Time complexity of merge is \\(O(n_1+n_2)\\) with \\(n_1\\) and \\(n_2\\) resp. the length of <code>t1</code> and <code>t2</code></p> <p>Returns:</p> Name Type Description <code>Array</code> <p>A fresh array, sorted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; def cmp (x,y): \n...    if x == y:\n...       return 0\n...    elif x &lt; y:\n...       return -1\n...    else:\n...       return 1\n&gt;&gt;&gt; t1 = numpy.array([0,2,5,6])\n&gt;&gt;&gt; t2 = numpy.array([1,3,4])\n&gt;&gt;&gt; merge(t1,t2,cmp)\narray([0, 1, 2, 3, 4, 5, 6])\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def merge (t1,t2, cmp):\n    \"\"\"\n    Given two sorted arrays, creates a fresh sorted array.\n\n    Args:\n      t1 (Array): An array of objects\n      t2 (Array): An array of objects\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n\n    Note: Complexity\n          Time complexity of merge is $O(n_1+n_2)$ with\n          $n_1$ and $n_2$ resp. the length of `t1` and `t2`\n\n    Returns:\n      Array: A fresh array, sorted.\n\n    Examples:\n      &gt;&gt;&gt; import numpy\n      &gt;&gt;&gt; def cmp (x,y): \n      ...    if x == y:\n      ...       return 0\n      ...    elif x &lt; y:\n      ...       return -1\n      ...    else:\n      ...       return 1\n      &gt;&gt;&gt; t1 = numpy.array([0,2,5,6])\n      &gt;&gt;&gt; t2 = numpy.array([1,3,4])\n      &gt;&gt;&gt; merge(t1,t2,cmp)\n      array([0, 1, 2, 3, 4, 5, 6])\n    \"\"\"\n    n1 = len(t1)\n    n2 = len(t2)\n    t = np.zeros(n1+n2,dtype=type(t1[0]))\n    i = j = k = 0\n    while i &lt; n1 and j &lt; n2:\n        if cmp(t1[i],t2[j]) &lt; 0:\n            t[k] = t1[i]\n            i = i + 1\n        else:\n            t[k] = t2[j]\n            j = j + 1\n        k = k + 1\n    while i &lt; n1:\n        t[k] = t1[i]\n        i = i + 1\n        k = k + 1\n    while j &lt; n2:\n        t[k] = t2[j]\n        j = j + 1\n        k = k + 1\n    return t\n</code></pre>"},{"location":"modules/#src.sorting.merge_sort","title":"<code>merge_sort(t, cmp)</code>","text":"<p>A sorting function implementing the merge sort algorithm</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Array</code> <p>An array of integers</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required <p>Returns:</p> Name Type Description <code>Array</code> <p>A fresh array, sorted.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import generate\n&gt;&gt;&gt; def cmp_element (x,y): \n...    return x.cmp(y)\n&gt;&gt;&gt; t = generate.random_array(10)\n&gt;&gt;&gt; merge_sort(t,cmp_element)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=object)\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def merge_sort (t,cmp):\n    \"\"\"\n    A sorting function implementing the merge sort algorithm\n\n    Args:\n      t (Array): An array of integers\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n\n    Returns:\n      Array: A fresh array, sorted.\n\n    Examples:\n      &gt;&gt;&gt; import generate\n      &gt;&gt;&gt; def cmp_element (x,y): \n      ...    return x.cmp(y)\n      &gt;&gt;&gt; t = generate.random_array(10)\n      &gt;&gt;&gt; merge_sort(t,cmp_element)\n      array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=object)\n    \"\"\"\n    n = len(t)\n    if n &lt;= 1:\n        # cas de base\n        return copy.deepcopy(t)\n    else:\n        # cas general\n        t1 = merge_sort((t[0:((n-1)//2+1)]),cmp)\n        t2 = merge_sort((t[((n-1)//2+1):n]),cmp)\n        return merge(t1,t2,cmp)\n</code></pre>"},{"location":"modules/#src.sorting.naive_pivot","title":"<code>naive_pivot(s)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>s</code> <code>dict</code> <p>A slice of an array, that is a dictionary with 3 fields :         <code>data</code>, <code>left</code>, <code>right</code> representing resp. an array of objects and left          and right bounds of the slice.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>a position for the pivot. Systematically returns the first position    of the slice as a naive choice.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = {'data': None, 'left': 2, 'right': 10}\n&gt;&gt;&gt; naive_pivot(s)\n2\n&gt;&gt;&gt; s = {'data': None, 'left': 3, 'right': 10}\n&gt;&gt;&gt; naive_pivot(s)\n3\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def naive_pivot(s):\n    '''\n    Args:\n      s (dict): A slice of an array, that is a dictionary with 3 fields :\n                `data`, `left`, `right` representing resp. an array of objects and left\n                 and right bounds of the slice.\n\n    Returns:\n      int: a position for the pivot. Systematically returns the first position\n           of the slice as a naive choice.\n\n    Examples:\n      &gt;&gt;&gt; s = {'data': None, 'left': 2, 'right': 10}\n      &gt;&gt;&gt; naive_pivot(s)\n      2\n      &gt;&gt;&gt; s = {'data': None, 'left': 3, 'right': 10}\n      &gt;&gt;&gt; naive_pivot(s)\n      3\n    '''\n    return s['left']\n</code></pre>"},{"location":"modules/#src.sorting.optimal_pivot","title":"<code>optimal_pivot(s)</code>","text":"<p>Returns the index of the median element in the slice.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = {'data': [5, 1, 9, 3, 7], 'left': 0, 'right': 4}\n&gt;&gt;&gt; optimal_pivot(s)\n2\n&gt;&gt;&gt; s = {'data': [10, 20, 30, 40, 50], 'left': 1, 'right': 3}\n&gt;&gt;&gt; optimal_pivot(s)\n2\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def optimal_pivot(s):\n    \"\"\"\n    Returns the index of the median element in the slice.\n\n    Examples:\n      &gt;&gt;&gt; s = {'data': [5, 1, 9, 3, 7], 'left': 0, 'right': 4}\n      &gt;&gt;&gt; optimal_pivot(s)\n      2\n      &gt;&gt;&gt; s = {'data': [10, 20, 30, 40, 50], 'left': 1, 'right': 3}\n      &gt;&gt;&gt; optimal_pivot(s)\n      2\n    \"\"\"\n    return s['left'] + (s['right'] - s['left']) // 2\n</code></pre>"},{"location":"modules/#src.sorting.partition","title":"<code>partition(s, cmp, pivot_pos)</code>","text":"<p>Creates two slices from <code>s</code> by selecting in the first slice all elements that are lower than the pivot and in the second one all the other elements.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>dict</code> <p>A slice represented as a dictionary with 3 fields :</p> <ul> <li><code>data</code>: the array of objects,</li> <li><code>left</code>: left bound of the slice (a position in the array),</li> <li><code>right</code>: right bound of the slice.</li> </ul> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required <code>pivot_pos</code> <code>int</code> <p>The position at which we take the pivot in <code>s['data']</code></p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>A couple of slices, the first slice contains all elements that are </p> <p>less than the pivot, the second one contains all elements that are </p> <p>greater than the pivot, the pivot does not belong to any slice.</p> <p>At the end, in the array the pivot is after the left slice and before </p> <p>the right slice.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import generate\n&gt;&gt;&gt; import element\n&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; def cmp (x,y): \n...    if x == y:\n...       return 0\n...    elif x &lt; y:\n...       return -1\n...    else:\n...       return 1\n&gt;&gt;&gt; t = numpy.array([element.Element(i) for i in [5, 6, 1, 3, 4, 9, 8, 2, 7]])\n&gt;&gt;&gt; p = {'left':0,'right':len(t)-1,'data':t}\n&gt;&gt;&gt; p1,p2 = partition(p,cmp,0)\n&gt;&gt;&gt; list(p1['data'][p1['left']:p1['right']+1])\n[4, 2, 1, 3]\n&gt;&gt;&gt; list(p2['data'][p2['left']:p2['right']+1])\n[9, 8, 6, 7]\n&gt;&gt;&gt; t = numpy.array([2, 1])\n&gt;&gt;&gt; p = {'left': 0, 'right': len(t) - 1, 'data': t}\n&gt;&gt;&gt; p1, p2 = partition(p, cmp, 0)  # Pivot = 2\n&gt;&gt;&gt; list(map(int, p1['data'][p1['left']:p1['right'] + 1]))\n[1]\n&gt;&gt;&gt; list(p2['data'][p2['left']:p2['right'] + 1])\n[]\n</code></pre> Attention <p>FINIR D'\u00c9CRIRE LES DOCTESTS</p> <ul> <li>Remplacer <code>None</code> par la valeur attendue</li> <li>Rajouter des tests</li> </ul> Source code in <code>src/sorting.py</code> <pre><code>def partition (s, cmp, pivot_pos):\n    \"\"\"\n    Creates two slices from `s` by selecting in the first slice all\n    elements that are lower than the pivot and in the second one all the other\n    elements.\n\n    Args:\n      s (dict): A slice represented as a dictionary with 3 fields :\n\n          * `data`: the array of objects,\n          * `left`: left bound of the slice (a position in the array),\n          * `right`: right bound of the slice.\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n      pivot_pos (int): The position at which we take the pivot in `s['data']`\n\n    Returns:\n      tuple: A couple of slices, the first slice contains all elements that are \n      less than the pivot, the second one contains all elements that are \n      greater than the pivot, the pivot does not belong to any slice.\n      At the end, in the array the pivot is after the left slice and before \n      the right slice.\n\n    Examples:\n      &gt;&gt;&gt; import generate\n      &gt;&gt;&gt; import element\n      &gt;&gt;&gt; import numpy\n      &gt;&gt;&gt; def cmp (x,y): \n      ...    if x == y:\n      ...       return 0\n      ...    elif x &lt; y:\n      ...       return -1\n      ...    else:\n      ...       return 1\n      &gt;&gt;&gt; t = numpy.array([element.Element(i) for i in [5, 6, 1, 3, 4, 9, 8, 2, 7]])\n      &gt;&gt;&gt; p = {'left':0,'right':len(t)-1,'data':t}\n      &gt;&gt;&gt; p1,p2 = partition(p,cmp,0)\n      &gt;&gt;&gt; list(p1['data'][p1['left']:p1['right']+1])\n      [4, 2, 1, 3]\n      &gt;&gt;&gt; list(p2['data'][p2['left']:p2['right']+1])\n      [9, 8, 6, 7]\n      &gt;&gt;&gt; t = numpy.array([2, 1])\n      &gt;&gt;&gt; p = {'left': 0, 'right': len(t) - 1, 'data': t}\n      &gt;&gt;&gt; p1, p2 = partition(p, cmp, 0)  # Pivot = 2\n      &gt;&gt;&gt; list(map(int, p1['data'][p1['left']:p1['right'] + 1]))\n      [1]\n      &gt;&gt;&gt; list(p2['data'][p2['left']:p2['right'] + 1])\n      []\n\n\n    Warning: Attention\n             **FINIR D'\u00c9CRIRE LES DOCTESTS**\n\n             * Remplacer `None` par la valeur attendue\n             * Rajouter des tests\n    \"\"\"\n    data = s['data']\n    left, right = s['left'], s['right']\n    pivot = data[pivot_pos]\n\n    data[left], data[pivot_pos] = data[pivot_pos], data[left]\n\n    i, j = left + 1, right\n\n    while i &lt;= j:\n        while i &lt;= j and cmp(data[i], pivot) &lt; 0:\n            i += 1\n        while i &lt;= j and cmp(data[j], pivot) &gt; 0:\n            j -= 1\n        if i &lt; j:\n            data[i], data[j] = data[j], data[i]\n            i += 1\n            j -= 1\n\n    data[left], data[j] = data[j], data[left]\n\n    return {\"data\": data, \"left\": left, \"right\": j - 1}, {\"data\": data, \"left\": j + 1, \"right\": right}\n</code></pre>"},{"location":"modules/#src.sorting.quicksort","title":"<code>quicksort(t, cmp, pivot_func)</code>","text":"<p>A sorting function implementing the quicksort algorithm on the whole array <code>t</code>.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>Array</code> <p>An array of Element</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required <code>pivot_func</code> <code>function</code> <p>A function that returns the pivot index inside a slice.</p> required <p>Returns: Nothing</p> Note <p><code>t</code> is modified during the sort process</p> Attention <p>\u00c9CRIRE LES DOCTESTS</p> <p>import numpy def cmp (x,y):  ...    if x == y: ...       return 0 ...    elif x &lt; y: ...       return -1 ...    else: ...       return 1 t = numpy.array([5, 6, 1, 3, 4, 9, 8, 2, 7]) quicksort(t, cmp, random_pivot) list(map(int,t)) [1, 2, 3, 4, 5, 6, 7, 8, 9]</p> Source code in <code>src/sorting.py</code> <pre><code>def quicksort (t, cmp, pivot_func):\n    \"\"\"\n    A sorting function implementing the quicksort algorithm on the whole array `t`.\n\n    Args:\n      t (Array): An array of Element\n      cmp (function: A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n      pivot_func (function): A function that returns the pivot index inside a slice.\n\n    **Returns:** Nothing\n\n    Note:\n          `t` is modified during the sort process\n\n    Warning: Attention\n             **\u00c9CRIRE LES DOCTESTS**\n    &gt;&gt;&gt; import numpy\n    &gt;&gt;&gt; def cmp (x,y): \n    ...    if x == y:\n    ...       return 0\n    ...    elif x &lt; y:\n    ...       return -1\n    ...    else:\n    ...       return 1\n    &gt;&gt;&gt; t = numpy.array([5, 6, 1, 3, 4, 9, 8, 2, 7])\n    &gt;&gt;&gt; quicksort(t, cmp, random_pivot)\n    &gt;&gt;&gt; list(map(int,t))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    s = {'data':t, 'left':0, 'right':len(t)-1}\n    quicksort_slice(s, cmp, pivot_func)\n</code></pre>"},{"location":"modules/#src.sorting.quicksort_slice","title":"<code>quicksort_slice(s, cmp, pivot_func)</code>","text":"<p>A sorting function implementing the quicksort algorithm.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>dict</code> <p>A slice of an array, that is a dictionary with 3 fields :         <code>data</code>, <code>left</code>, <code>right</code> representing resp. an array of objects and left          and right bounds of the slice.</p> required <code>cmp</code> <code>function</code> <p>A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b</p> required <code>pivot_func</code> <code>function</code> <p>A function that returns the pivot index inside a slice.</p> required <p>Returns: Nothing</p> Attention <p>\u00c9CRIRE LES DOCTESTS</p> <p>import numpy def cmp (x,y):  ...    if x == y: ...       return 0 ...    elif x &lt; y: ...       return -1 ...    else: ...       return 1 t = numpy.array([5, 6, 1, 3, 4, 9, 8, 2, 7]) s = {'left': 0, 'right': len(t) - 1, 'data': t} quicksort_slice(s, cmp, random_pivot) list(map(int,s['data'])) [1, 2, 3, 4, 5, 6, 7, 8, 9]</p> Source code in <code>src/sorting.py</code> <pre><code>def quicksort_slice (s, cmp, pivot_func):\n    \"\"\"\n    A sorting function implementing the quicksort algorithm.\n\n    Args:\n      s (dict): A slice of an array, that is a dictionary with 3 fields :\n                `data`, `left`, `right` representing resp. an array of objects and left\n                 and right bounds of the slice.\n      cmp (function): A comparison function, returning 0 if a == b, -1 is a &lt; b, 1 if a &gt; b\n      pivot_func (function): A function that returns the pivot index inside a slice.\n    **Returns:** Nothing\n\n    Warning: Attention\n             **\u00c9CRIRE LES DOCTESTS**\n    &gt;&gt;&gt; import numpy\n    &gt;&gt;&gt; def cmp (x,y): \n    ...    if x == y:\n    ...       return 0\n    ...    elif x &lt; y:\n    ...       return -1\n    ...    else:\n    ...       return 1\n    &gt;&gt;&gt; t = numpy.array([5, 6, 1, 3, 4, 9, 8, 2, 7])\n    &gt;&gt;&gt; s = {'left': 0, 'right': len(t) - 1, 'data': t}\n    &gt;&gt;&gt; quicksort_slice(s, cmp, random_pivot)\n    &gt;&gt;&gt; list(map(int,s['data']))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n\n    if s['left'] &lt; s['right']:\n        pivot_pos = pivot_func(s)\n        (s1, s2) = partition(s, cmp, pivot_pos)\n        if s1['left'] &lt; s1['right']:\n            quicksort_slice(s1, cmp, pivot_func)\n        if s2['left'] &lt; s2['right']:\n            quicksort_slice(s2, cmp, pivot_func)\n</code></pre>"},{"location":"modules/#src.sorting.random_pivot","title":"<code>random_pivot(s)</code>","text":"<p>Returns a random index between <code>left</code> and <code>right</code> (inclusive).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>dict</code> <p>A dictionary representing a slice of an array, containing:         - \"left\": left bound,         - \"right\": right bound.</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>A random integer between <code>s['left']</code> and <code>s['right']</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.seed(42)\n&gt;&gt;&gt; s = {'left': 2, 'right': 10}\n&gt;&gt;&gt; random_pivot(s) in range(s['left'], s['right'] + 1)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; s = {'left': 0, 'right': 5}\n&gt;&gt;&gt; pivot = random_pivot(s)\n&gt;&gt;&gt; s['left'] &lt;= pivot &lt;= s['right']\nTrue\n</code></pre> Source code in <code>src/sorting.py</code> <pre><code>def random_pivot(s):\n    \"\"\"\n    Returns a random index between `left` and `right` (inclusive).\n\n    Args:\n      s (dict): A dictionary representing a slice of an array, containing:\n                - \"left\": left bound,\n                - \"right\": right bound.\n\n    Returns:\n      int: A random integer between `s['left']` and `s['right']`.\n\n    Examples:\n      &gt;&gt;&gt; import random\n      &gt;&gt;&gt; random.seed(42)\n      &gt;&gt;&gt; s = {'left': 2, 'right': 10}\n      &gt;&gt;&gt; random_pivot(s) in range(s['left'], s['right'] + 1)\n      True\n\n      &gt;&gt;&gt; s = {'left': 0, 'right': 5}\n      &gt;&gt;&gt; pivot = random_pivot(s)\n      &gt;&gt;&gt; s['left'] &lt;= pivot &lt;= s['right']\n      True\n      \"\"\"\n\n    left_index=s['left']\n    right_index=s['right']\n    return random.randint(left_index, right_index)  \n</code></pre>"},{"location":"modules/#module-test","title":"Module <code>Test</code>","text":"<p>Test module for quicksort assignment</p> Author <p>Dpt Informatique - FST - Univ. Lille 2018, january</p>"},{"location":"modules/#src.test.cmp","title":"<code>cmp(a, b)</code>","text":"<p>A comparison function</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Element</code> <p>First element    </p> required <code>b</code> <code>Element</code> <p>Second element</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>0 if a == b, 1 if a &gt; b, -1 if a &lt; b</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from element import Element\n&gt;&gt;&gt; cpt = 0\n&gt;&gt;&gt; cmp(Element(10),Element(5))\n1\n&gt;&gt;&gt; cmp(Element(5),Element(5))\n0\n&gt;&gt;&gt; cmp(Element(5),Element(10))\n-1\n</code></pre> Source code in <code>src/test.py</code> <pre><code>def cmp(a,b):\n    \"\"\"\n    A comparison function\n\n    Args:\n      a (Element): First element    \n      b (Element): Second element\n\n    Returns:\n      int: 0 if a == b, 1 if a &gt; b, -1 if a &lt; b\n\n    Examples:\n      &gt;&gt;&gt; from element import Element\n      &gt;&gt;&gt; cpt = 0\n      &gt;&gt;&gt; cmp(Element(10),Element(5))\n      1\n      &gt;&gt;&gt; cmp(Element(5),Element(5))\n      0\n      &gt;&gt;&gt; cmp(Element(5),Element(10))\n      -1\n    \"\"\"\n    global cpt\n    cpt = cpt + 1\n    return Element.cmp(a,b)\n</code></pre>"},{"location":"modules/#src.test.increasing_100","title":"<code>increasing_100()</code>","text":"<p>Runs sorting benchmarks on increasing arrays (sorted order) of sizes 1 to 100. Stores the average number of comparisons for: - MergeSort - QuickSort (naive pivot) - QuickSort (random pivot)</p> <p>Results are written to <code>increasing_100.dat</code>.</p> Source code in <code>src/test.py</code> <pre><code>def increasing_100():\n    \"\"\"\n    Runs sorting benchmarks on **increasing** arrays (sorted order) of sizes 1 to 100.\n    Stores the average number of comparisons for:\n    - MergeSort\n    - QuickSort (naive pivot)\n    - QuickSort (random pivot)\n\n    Results are written to `increasing_100.dat`.\n    \"\"\"\n    with open(\"increasing_100.dat\", \"w\") as file:\n\n        for size in range(1, 101):\n            global cpt\n            merge_total = 0\n            quick_naive_total = 0\n            quick_random_total = 0\n\n            for i in range(100):\n                array1 = generate.increasing_array(size)\n                array2 = copy.deepcopy(array1)\n                array3 = copy.deepcopy(array1)\n\n                cpt = 0\n                sorting.merge_sort(array1, cmp)\n                merge_total += cpt\n\n                cpt = 0\n                sorting.quicksort(array2, cmp, sorting.naive_pivot)\n                quick_naive_total += cpt\n\n                cpt = 0\n                sorting.quicksort(array3, cmp, sorting.random_pivot)\n                quick_random_total += cpt\n\n            avg_merge = merge_total / 100\n            avg_quick_naive = quick_naive_total / 100\n            avg_quick_random = quick_random_total / 100\n\n            file.write(f\"{size} {avg_merge:.2f} {avg_quick_naive:.2f} {avg_quick_random:.2f}\\n\")\n</code></pre>"},{"location":"modules/#src.test.optimal_100","title":"<code>optimal_100()</code>","text":"<p>Runs sorting benchmarks using the optimal pivot (median) for QuickSort on randomly generated arrays of sizes 1 to 100. Stores the average number of comparisons in <code>optimal_100.dat</code>.</p> Source code in <code>src/test.py</code> <pre><code>def optimal_100():\n    \"\"\"\n    Runs sorting benchmarks using the optimal pivot (median) for QuickSort\n    on randomly generated arrays of sizes 1 to 100.\n    Stores the average number of comparisons in `optimal_100.dat`.\n    \"\"\"\n    with open(\"optimal_100.dat\", \"w\") as file:\n        print(\"Running benchmarks with optimal pivot...\")\n\n        for size in range(1, 101):\n            global cpt\n            quick_optimal_total = 0\n\n            for _ in range(100):\n                array = generate.random_array(size)\n\n                cpt = 0\n                sorting.quicksort(array, cmp, sorting.optimal_pivot)\n                quick_optimal_total += cpt\n\n            avg_quick_optimal = quick_optimal_total / 100\n\n            file.write(f\"{size} {avg_quick_optimal:.2f}\\n\")\n\n            if size % 10 == 0:\n                print(f\"Tests pour taille {size} compl\u00e9t\u00e9s...\")\n\n        print(\"\u2705 Benchmarks termin\u00e9s avec optimal pivot ! R\u00e9sultats enregistr\u00e9s dans 'optimal_100.dat'.\")\n</code></pre>"},{"location":"modules/#src.test.random_100","title":"<code>random_100()</code>","text":"<p>Runs sorting benchmarks on arrays of sizes 1 to 100 with 100 trials each. Stores the average number of comparisons for: - Merge Sort - QuickSort (naive pivot) - QuickSort (random pivot)</p> <p>The results are written to <code>random_100.dat</code></p> Source code in <code>src/test.py</code> <pre><code>def random_100():\n    \"\"\"\n    Runs sorting benchmarks on arrays of sizes 1 to 100 with 100 trials each.\n    Stores the average number of comparisons for:\n    - Merge Sort\n    - QuickSort (naive pivot)\n    - QuickSort (random pivot)\n\n    The results are written to `random_100.dat`\n    \"\"\"\n    with open(\"random_100.dat\", \"w\") as file:\n        for size in range(1, 101):\n            global cpt\n            merge_total = 0\n            quick_naive_total = 0\n            quick_random_total = 0\n\n            for i in range(100):\n                array1 = generate.random_array(size)\n                array2 = copy.deepcopy(array1)\n                array3 = copy.deepcopy(array1)\n\n                cpt = 0\n                sorting.merge_sort(array1, cmp)\n                merge_total += cpt\n\n                cpt = 0\n                sorting.quicksort(array2, cmp, sorting.naive_pivot)\n                quick_naive_total += cpt\n\n                cpt = 0\n                sorting.quicksort(array3, cmp, sorting.random_pivot)\n                quick_random_total += cpt\n\n            avg_merge = merge_total / 100\n            avg_quick_naive = quick_naive_total / 100\n            avg_quick_random = quick_random_total / 100\n\n            file.write(f\"{size} {avg_merge:.2f} {avg_quick_naive:.2f} {avg_quick_random:.2f}\\n\")\n</code></pre>"}]}